<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mortar Documentation</title>
    <link>https://go-masonry.github.io/</link>
    <description>Recent content on Mortar Documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 10 Dec 2020 13:08:23 +0200</lastBuildDate><atom:link href="https://go-masonry.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bricks</title>
      <link>https://go-masonry.github.io/mortar/bricks/</link>
      <pubDate>Thu, 10 Dec 2020 13:08:23 +0200</pubDate>
      
      <guid>https://go-masonry.github.io/mortar/bricks/</guid>
      <description>When we build software most of us always try to rely on something we or others build before us. Since we don&amp;rsquo;t want to reinvent the wheel, again.
Go standard library is an excellent example here. There are strings, time, http and many other build-in libraries that we use. While this example is great, it doesn&amp;rsquo;t scale to 3rd party libraries.
Let&amp;rsquo;s look at Logger libraries for example, there are</description>
    </item>
    
    <item>
      <title>Builder Pattern</title>
      <link>https://go-masonry.github.io/mortar/builders/</link>
      <pubDate>Thu, 10 Dec 2020 13:08:23 +0200</pubDate>
      
      <guid>https://go-masonry.github.io/mortar/builders/</guid>
      <description>You probably used to Functional Options pattern. But we found Builder pattern to be very useful, here we will explain why.
Motivation  &amp;ldquo;See&amp;rdquo; all the options without searching for them Partial Builders  Override previously set values    Library usage within the organization +---------------------+ +-------------------------------+ +-------------------------+ | Library Developer | +--------&amp;gt; | Platform/Infra/Ops Developer | +-------&amp;gt; | Integration Developer | +---------------------+ +-------------------------------+ +-------------------------+ Develops the library to be used Pre Configure the library specifically Set final values in different scenarios, expose to their organization.</description>
    </item>
    
    <item>
      <title>Configuration Map</title>
      <link>https://go-masonry.github.io/mortar/config/</link>
      <pubDate>Thu, 10 Dec 2020 13:08:23 +0200</pubDate>
      
      <guid>https://go-masonry.github.io/mortar/config/</guid>
      <description>It is good practice to use constants in your code instead of magic numbers and it&amp;rsquo;s even better to set them outside your code either by providing a config file or reading from Environment variable. Mortar have a Config interface that is used everywhere to read external configurations. While Mortar can be configured explicitly and that gives you total control over it. It is much comfortable to use its defaults. To read them Mortar expects a dedicated Configuration key called mortar</description>
    </item>
    
    <item>
      <title>Listeners</title>
      <link>https://go-masonry.github.io/mortar/listeners/</link>
      <pubDate>Thu, 10 Dec 2020 13:08:23 +0200</pubDate>
      
      <guid>https://go-masonry.github.io/mortar/listeners/</guid>
      <description>We assume that you, like us, don&amp;rsquo;t expose your services to the world without setting up at least a Load Balancer before it/them. Historically when we started building webservices our infrastructure was expecting a single port to forward all the traffic to it from the LoadBalancer. When we wanted to use gRPC API as well as REST we still had to expose everything under one port. Fortunately we weren&amp;rsquo;t the first, and we used this excellent cmux library to solve that problem.</description>
    </item>
    
    <item>
      <title>gRPC-Gateway</title>
      <link>https://go-masonry.github.io/api/rest/grpc-gw/</link>
      <pubDate>Wed, 09 Dec 2020 10:41:15 +0200</pubDate>
      
      <guid>https://go-masonry.github.io/api/rest/grpc-gw/</guid>
      <description>Mortar comes with grpc-gateway which is a reverse-proxy that translates a RESTful HTTP API into gRPC. We will show how you should register it&amp;rsquo;s handlers after you generate them from the proto files.
Register grpc-gateway Handlers Before reading this part get yourself familiar with the gRPC API counterpart.
 If you read the gRPC part, you simply need to add one function to Uber-FX graph. This function should return a slice of GRPCGatewayGeneratedHandlers.</description>
    </item>
    
    <item>
      <title>HTTP Handlers</title>
      <link>https://go-masonry.github.io/api/rest/handlers/</link>
      <pubDate>Wed, 09 Dec 2020 10:41:15 +0200</pubDate>
      
      <guid>https://go-masonry.github.io/api/rest/handlers/</guid>
      <description>Although it&amp;rsquo;s very convenient to use gRPC + gRPC-Gateway to serve RESTful API, you sometime want to use prebuilt HTTP Handler/HandlerFunc or similar.
Mortar provides 2 fx.Group for that. ExternalHTTPHandlers and ExternalHTTPHandlerFunctions, one for http.Handler the other for http.HandlerFunc.
To better understand Mortar groups read here
 Registering http.Handler To register a new http.Handler you need to define how it&amp;rsquo;s going to be served == Pattern.
  Create HTTPHandlerPatternPair</description>
    </item>
    
    <item>
      <title>Context</title>
      <link>https://go-masonry.github.io/middleware/context/</link>
      <pubDate>Sun, 06 Dec 2020 10:35:11 +0200</pubDate>
      
      <guid>https://go-masonry.github.io/middleware/context/</guid>
      <description>If you are not familiar with context.Context please read this and that first.
From context documentation package
Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context. Since we are building a gRPC Web Service it&amp;rsquo;s part of the design. Everything gRPC related already have a context.Context as the first argument.
gRPC  client
func (cc *ClientConn) Invoke(ctx context.Context, method string, args, reply interface{}, opts .</description>
    </item>
    
    <item>
      <title>Logging</title>
      <link>https://go-masonry.github.io/middleware/telemetry/logging/</link>
      <pubDate>Sun, 06 Dec 2020 09:43:50 +0200</pubDate>
      
      <guid>https://go-masonry.github.io/middleware/telemetry/logging/</guid>
      <description>Logging is extremely important, that is why Golang standard library have one. However there are better alternatives and it&amp;rsquo;s up to you to choose the one you want. You will need to wrap it to implement Mortar Logger Interface and you good to go. We already done that for zerolog.
One of the goals for Mortar Logger Interface was for it to be flexible, but most importantly it had to include context.</description>
    </item>
    
    <item>
      <title>Dependency Pattern</title>
      <link>https://go-masonry.github.io/fx/dependency/</link>
      <pubDate>Sat, 05 Dec 2020 13:18:51 +0200</pubDate>
      
      <guid>https://go-masonry.github.io/fx/dependency/</guid>
      <description>We are using this pattern when creating a new Uber-FX dependency, it makes it easy adding new external dependencies later when your application evolves. To explain this better we will do this with a Notifier example.
Preparation   Define our Notifier Interface. type Notifier interface{ Alert(ctx context.Context, msg string) } 
   Create a dependency &amp;ldquo;container&amp;rdquo; for all future dependencies of the Notifier implementation and embed fx.In into it.</description>
    </item>
    
    <item>
      <title>Groups</title>
      <link>https://go-masonry.github.io/fx/groups/</link>
      <pubDate>Sat, 05 Dec 2020 13:18:51 +0200</pubDate>
      
      <guid>https://go-masonry.github.io/fx/groups/</guid>
      <description>Uber-FX group is a feature that allows you to consume and produce multiple values of the same type. This make it easier to influence/configure different instances.
Mortar have different groups, but we will focus on one of them here.
Internal HTTP Handlers// InternalHTTPHandlers - Internal Http Handlers group. Mortar comes with several internal handlers, you can add yours. InternalHTTPHandlers = partial.FxGroupInternalHTTPHandlers //InternalHTTPHandlerFunctions - Internal Http Handler Functions group. Similar toInternalHttpHandlers but for functions InternalHTTPHandlerFunctions = partial.</description>
    </item>
    
    <item>
      <title>Tests</title>
      <link>https://go-masonry.github.io/fx/tests/</link>
      <pubDate>Sat, 05 Dec 2020 13:18:51 +0200</pubDate>
      
      <guid>https://go-masonry.github.io/fx/tests/</guid>
      <description>Testing with Uber-FX makes it possible to test different logic while mocking parts of the DI graph.
Constructor per Type While it&amp;rsquo;s possible to register several instances using one Constructor function, If possible avoid this.
Official Uber-FX documentation// Functions may also return multiple objects. For example, we could combine // NewHandler and NewLogger into a single function: // // func NewHandlerAndLogger() (*log.Logger, http.Handler, error) // // Fx also understands this idiom, and would treat NewHandlerAndLogger as the // constructor for both the *log.</description>
    </item>
    
  </channel>
</rss>
